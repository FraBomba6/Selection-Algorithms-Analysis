Index: src/Time.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import org.apache.poi.EncryptedDocumentException;\r\nimport org.apache.poi.ss.usermodel.*;\r\n\r\nimport java.lang.Math;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\n\r\npublic class Time {\r\n\r\n    /**\r\n     * Main algorithm that computes all the execution times for any of the three algorithms with random input and\r\n     * given k and fills an excel spreadsheet with all the obtained data\r\n     */\r\n    public static void main(String[] args) {\r\n        try {\r\n            int targetSize;\r\n            long maxError = Resolution.getResolution()*101;\r\n            String fileName = \"Time.xlsx\";\r\n            //Initializing a new excel file and sheet in which data will be registered\r\n            FileInputStream inputStream = new FileInputStream(new File(fileName));\r\n            Workbook workbook = WorkbookFactory.create(inputStream);\r\n\r\n            System.out.println(\"Warming up JVM...\");\r\n            for(int repetition = 10; repetition < 200000; repetition+=50) {\r\n                int[] warmUpArray = RandomTest.randomInput(repetition);\r\n                getExTimeHeapSelect(warmUpArray, repetition/2, maxError);\r\n                getExTimeMedianSelect(warmUpArray, repetition/2, maxError);\r\n                getExTimeQuickSelect(warmUpArray, repetition/2, maxError);\r\n                }\r\n\r\n            //For each iteration generates a targetsize for the array based on the exponential function\r\n            for(int iter = 0; iter < 50; iter++){\r\n                targetSize = (int)(Math.pow(1.25, iter)*10);\r\n\r\n                //builds the random filled array based on the target size and sets 4 different values for k\r\n                int[] kArray = {5, targetSize/2, (int)(Math.log(targetSize)/Math.log(2)), (targetSize - 5)};\r\n\r\n                //Compute the execution time 50 times for every algorithm choosing a different k every time.\r\n                for (int i = 0; i < 4; i++) {\r\n                    int k = kArray[i];\r\n                    Sheet sheet = workbook.getSheetAt(iter);\r\n                    System.out.println(\"Sheet \" + iter + \"    Array length: \" + sheet.getSheetName() + \"    k: \" + kArray[i]);\r\n                    for (int row_index = 4; row_index < 54; row_index++) {\r\n                        int[] input = RandomTest.randomInput(targetSize);\r\n                        //New line\r\n                        Row row = sheet.getRow(row_index);\r\n                        Cell cell = row.createCell(5*i);\r\n\r\n                        //Executes heap select\r\n                        cell.setCellValue(getExTimeHeapSelect(input, k, maxError));\r\n                        cell = row.createCell(5*i + 1);\r\n                        //Executes Quick select\r\n                        cell.setCellValue(getExTimeQuickSelect(input, k, maxError));\r\n                        cell = row.createCell(5*i + 2);\r\n                        //Executes Median of Medians select\r\n                        cell.setCellValue(getExTimeMedianSelect(input, k, maxError));\r\n                    }\r\n                }\r\n            }\r\n\r\n            inputStream.close();\r\n\r\n            //saves the excel file created before\r\n            FileOutputStream outputStream = new FileOutputStream(fileName);\r\n            workbook.write(outputStream);\r\n            workbook.close();\r\n            outputStream.close();\r\n        } catch (IOException | EncryptedDocumentException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Computes the execution time for minHeap selection algorithm\r\n     *\r\n     * @return the execution time as a long value\r\n     */\r\n    public static long getExTimeHeapSelect(int[] array, int k, long maxError) {\r\n        long start, end;\r\n        int count = 0;\r\n        start = System.nanoTime();\r\n        do {\r\n            HeapSelect.heapSelect(array, k);\r\n            end = System.nanoTime();\r\n            count++;\r\n        } while (end - start <= maxError);\r\n\r\n        return (end - start) / count;\r\n    }\r\n\r\n\r\n    /**\r\n     * Computes execution time for median of medians selection algorithm\r\n     *\r\n     * @return the execution time as a long value\r\n     */\r\n    public static long getExTimeMedianSelect(int[] array, int k, long maxError) {\r\n        long start, end;\r\n        int count = 0;\r\n        start = System.nanoTime();\r\n        do {\r\n            MedianSelect.medianSelect(array, 0, array.length - 1, k-1);\r\n            end = System.nanoTime();\r\n            count++;\r\n        } while (end - start <= maxError);\r\n\r\n        return (end - start) / count;\r\n    }\r\n\r\n\r\n    /**\r\n     * Computes execution time for quick select algorithm\r\n     *\r\n     * @return the execution time as a long value\r\n     */\r\n    public static long getExTimeQuickSelect(int[] array, int k, long maxError) {\r\n        long start, end;\r\n        int count = 0;\r\n        start = System.nanoTime();\r\n        do {\r\n            QuickSelect.quickSelect(array, 0, array.length - 1, k-1);\r\n            end = System.nanoTime();\r\n            count++;\r\n        } while (end - start <= maxError);\r\n\r\n        return (end - start) / count;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Time.java	(revision dcec723ca5db19a617442151a50264606ea60349)
+++ src/Time.java	(date 1588621355090)
@@ -83,7 +83,7 @@
         int count = 0;
         start = System.nanoTime();
         do {
-            HeapSelect.heapSelect(array, k);
+            Old_HeapSelect.heapSelect(array, k);
             end = System.nanoTime();
             count++;
         } while (end - start <= maxError);
Index: src/HeapSelect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.Vector;\r\nimport java.util.Collections;\r\n\r\n/**\r\n * Defines pair object that will be used for storing a pair (key, original position) during heap selection algorithm\r\n */\r\n\r\nclass Pair {\r\n    Integer key;\r\n    Integer position;\r\n\r\n    /**\r\n     * Constructor for a pair\r\n     * @param key REQUIRED Not null\r\n     * @param position REQUIRED not null\r\n     */\r\n    Pair(Integer key, Integer position) {\r\n        this.key = key;\r\n        this.position = position;\r\n    }\r\n\r\n    /**\r\n     * getter for key\r\n     */\r\n    public Integer getKey() {\r\n        return key;\r\n    }\r\n\r\n    /**\r\n     * setter for key\r\n     */\r\n    public void setKey(Integer key) {\r\n        this.key = key;\r\n    }\r\n\r\n\r\n    /**\r\n     * getter for position\r\n     */\r\n    public Integer getPosition() {\r\n        return position;\r\n    }\r\n\r\n    /**\r\n     * setter for position\r\n     */\r\n    public void setPosition(Integer position) {\r\n        this.position = position;\r\n    }\r\n}\r\n\r\npublic class HeapSelect {\r\n    /*\r\n    public static void main(String[] args) {\r\n        System.out.print(\"Enter an array of integers: \");\r\n        Scanner input = new Scanner(System.in);\r\n        String inVector =  input.nextLine();\r\n        int[] array = getInputVector(inVector);\r\n        System.out.print(\"Enter an integer: \");\r\n        int k = input.nextInt();\r\n\r\n        heapSelect(array, k);\r\n    }*/\r\n\r\n    /**\r\n     * Splits the input line in all the different values\r\n     * @param inputLine required as a string of ints divided by one (or more) blank spaces\r\n     * @return an int array containing all the ints from the input\r\n     */\r\n    static int[] getInputVector(String inputLine) {\r\n        String els[] = inputLine.split(\"\\\\s+\");\r\n        int length = els.length;\r\n        int[] output = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            output[i] = Integer.parseInt(els[i]);\r\n        }\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Build the auxiliary data structures basing on the input and runs min/max heapSelect according to input's size\r\n     * @param array the array with input values. REQUIRED not empty, at least one element\r\n     * @param k index for the algorithm, REQUIRED 0<=k< array length\r\n     */\r\n    public static void heapSelect(int[] array, int k){\r\n        Vector<Pair> h1 = new Vector<Pair>(10);\r\n        for (int i : array)\r\n            h1.add(new Pair(i, null));\r\n        if (k <= h1.size()/2)\r\n            buildMinHeap(h1);\r\n        else\r\n            buildMaxHeap(h1);\r\n        Vector<Pair> h2 = new Vector<Pair>(k);\r\n        Pair root = h1.get(0);\r\n        root.setPosition(0);\r\n        h2.add(root);\r\n\r\n        if (k <= h1.size()/2)\r\n            minHeapSelect(h1, h2, k);\r\n        else\r\n            maxHeapSelect(h1, h2, k);\r\n\r\n        //System.out.println(h2.get(0).getKey());\r\n    }\r\n\r\n    /**\r\n     * Selects k-th element in a vector with O(k log k) time complexity\r\n     * @param h1 first vector of Pairs. REQUIRED not empty\r\n     * @param h2 second vector of Pairs. REQUIRED not empty\r\n     * @param k index for the selected element\r\n     */\r\n    public static void minHeapSelect(Vector<Pair> h1, Vector<Pair> h2, int k){\r\n        Pair left, right, root;\r\n        for(int i = 0; i < k-1; i++) {\r\n            root = h2.get(0);\r\n            int rootPos = root.getPosition();\r\n            int l = rootPos * 2 + 1;\r\n            int r = rootPos * 2 + 2;\r\n            extract(h2, true);\r\n            if(l < h1.size()) {\r\n                left = h1.get(l);\r\n                left.setPosition(l);\r\n                h2.add(left);\r\n                int child = h2.size() - 1;\r\n                while(child > 0 && h2.get(child).getKey() < h2.get((child - 1) / 2).getKey()) {\r\n                    Collections.swap(h2, child, (child - 1) / 2);\r\n                    child = (child - 1) / 2;\r\n                }\r\n            }\r\n            if(r < h1.size()){\r\n                right = h1.get(r);\r\n                right.setPosition(r);\r\n                h2.add(right);\r\n                int child = h2.size() - 1;\r\n                while(child > 0 && h2.get(child).getKey() < h2.get((child - 1) / 2).getKey()) {\r\n                    Collections.swap(h2, child, (child - 1) / 2);\r\n                    child = (child - 1) / 2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Selects k-th element in a vector with O(k log k) time complexity\r\n     * @param h1 first vector of Pairs. REQUIRED not empty\r\n     * @param h2 second vector of Pairs. REQUIRED not empty\r\n     * @param k index for the selected element\r\n     */\r\n    public static void maxHeapSelect(Vector<Pair> h1, Vector<Pair> h2, int k){\r\n        Pair left, right, root;\r\n        for(int i = h1.size()-1; i > k-1; i--) {\r\n            root = h2.get(0);\r\n            int rootPos = root.getPosition();\r\n            int l = rootPos * 2 + 1;\r\n            int r = rootPos * 2 + 2;\r\n            extract(h2, false);\r\n            if(l < h1.size()) {\r\n                left = h1.get(l);\r\n                left.setPosition(l);\r\n                h2.add(left);\r\n                int child = h2.size() - 1;\r\n                while(child > 0 && h2.get(child).getKey() > h2.get((child - 1) / 2).getKey()) {\r\n                    Collections.swap(h2, child, (child - 1) / 2);\r\n                    child = (child - 1) / 2;\r\n                }\r\n            }\r\n            if(r < h1.size()){\r\n                right = h1.get(r);\r\n                right.setPosition(r);\r\n                h2.add(right);\r\n                int child = h2.size() - 1;\r\n                while(child > 0 && h2.get(child).getKey() > h2.get((child - 1) / 2).getKey()) {\r\n                    Collections.swap(h2, child, (child - 1) / 2);\r\n                    child = (child - 1) / 2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a vector of pairs, builds a minHeap\r\n     * @param vector the vector of pairs\r\n     */\r\n    public static void buildMinHeap(Vector<Pair> vector) {\r\n        for(int i = vector.size()/2 - 1; i >= 0; i--) {\r\n            minHeapify(vector, i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a vector of pairs, builds a maxHeap\r\n     * @param vector the vector of pairs\r\n     */\r\n    public static void buildMaxHeap(Vector<Pair> vector) {\r\n        for(int i = vector.size()/2 - 1; i >= 0; i--) {\r\n            maxHeapify(vector, i);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * maxHeapify algorithm with O(log n) or O(log k) time complexity\r\n     * @param vector the vector of pairs that will be turned into a minHeap\r\n     * @param i starting index for the algorithm. REQUIRED 0 <= i< vector length\r\n     */\r\n    private static void maxHeapify(Vector<Pair> vector, int i) {\r\n        int n = vector.size();\r\n        int greatest = i;\r\n        int l = 2*i + 1;\r\n        int r = 2*i + 2;\r\n\r\n        if(l < n && vector.get(l).getKey() > vector.get(greatest).getKey())\r\n            greatest = l;\r\n        if(r < n && vector.get(r).getKey() > vector.get(greatest).getKey())\r\n            greatest = r;\r\n        if(greatest != i) {\r\n            Collections.swap(vector, i, greatest);\r\n            maxHeapify(vector, greatest);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * minHeapify algorithm with O(log n) or O(log k) time complexity\r\n     * @param vector the vector of pairs that will be turned into a minHeap\r\n     * @param i starting index for the algorithm. REQUIRED 0 <= i< vector length\r\n     */\r\n    public static void minHeapify(Vector<Pair> vector, int i) {\r\n        int n = vector.size();\r\n        int smallest = i;\r\n        int l = 2*i + 1;\r\n        int r = 2*i + 2;\r\n\r\n        if(l < n && vector.get(l).getKey() < vector.get(smallest).getKey())\r\n            smallest = l;\r\n        if(r < n && vector.get(r).getKey() < vector.get(smallest).getKey())\r\n            smallest = r;\r\n        if(smallest != i) {\r\n            Collections.swap(vector, i, smallest);\r\n            minHeapify(vector, smallest);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extracts the upper element from the vector making sure to keep the minHeap valid\r\n     * @param vector the heap vector. REQUIRED as a minHeap or a maxHeap\r\n     * @param min\r\n     */\r\n    public static void extract(Vector<Pair> vector, boolean min) {\r\n        Collections.swap(vector, 0, vector.size() - 1);\r\n        vector.remove(vector.size() - 1);\r\n        if(min)\r\n            minHeapify(vector, 0);\r\n        else\r\n            maxHeapify(vector, 0);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/HeapSelect.java	(revision dcec723ca5db19a617442151a50264606ea60349)
+++ src/HeapSelect.java	(date 1588621355077)
@@ -1,255 +1,4 @@
-import java.util.Vector;
-import java.util.Collections;
-
-/**
- * Defines pair object that will be used for storing a pair (key, original position) during heap selection algorithm
- */
-
-class Pair {
-    Integer key;
-    Integer position;
-
-    /**
-     * Constructor for a pair
-     * @param key REQUIRED Not null
-     * @param position REQUIRED not null
-     */
-    Pair(Integer key, Integer position) {
-        this.key = key;
-        this.position = position;
-    }
-
-    /**
-     * getter for key
-     */
-    public Integer getKey() {
-        return key;
-    }
-
-    /**
-     * setter for key
-     */
-    public void setKey(Integer key) {
-        this.key = key;
-    }
-
-
-    /**
-     * getter for position
-     */
-    public Integer getPosition() {
-        return position;
-    }
-
-    /**
-     * setter for position
-     */
-    public void setPosition(Integer position) {
-        this.position = position;
-    }
-}
 
 public class HeapSelect {
-    /*
-    public static void main(String[] args) {
-        System.out.print("Enter an array of integers: ");
-        Scanner input = new Scanner(System.in);
-        String inVector =  input.nextLine();
-        int[] array = getInputVector(inVector);
-        System.out.print("Enter an integer: ");
-        int k = input.nextInt();
-
-        heapSelect(array, k);
-    }*/
-
-    /**
-     * Splits the input line in all the different values
-     * @param inputLine required as a string of ints divided by one (or more) blank spaces
-     * @return an int array containing all the ints from the input
-     */
-    static int[] getInputVector(String inputLine) {
-        String els[] = inputLine.split("\\s+");
-        int length = els.length;
-        int[] output = new int[length];
-        for (int i = 0; i < length; i++) {
-            output[i] = Integer.parseInt(els[i]);
-        }
-        return output;
-    }
-
-    /**
-     * Build the auxiliary data structures basing on the input and runs min/max heapSelect according to input's size
-     * @param array the array with input values. REQUIRED not empty, at least one element
-     * @param k index for the algorithm, REQUIRED 0<=k< array length
-     */
-    public static void heapSelect(int[] array, int k){
-        Vector<Pair> h1 = new Vector<Pair>(10);
-        for (int i : array)
-            h1.add(new Pair(i, null));
-        if (k <= h1.size()/2)
-            buildMinHeap(h1);
-        else
-            buildMaxHeap(h1);
-        Vector<Pair> h2 = new Vector<Pair>(k);
-        Pair root = h1.get(0);
-        root.setPosition(0);
-        h2.add(root);
 
-        if (k <= h1.size()/2)
-            minHeapSelect(h1, h2, k);
-        else
-            maxHeapSelect(h1, h2, k);
-
-        //System.out.println(h2.get(0).getKey());
-    }
-
-    /**
-     * Selects k-th element in a vector with O(k log k) time complexity
-     * @param h1 first vector of Pairs. REQUIRED not empty
-     * @param h2 second vector of Pairs. REQUIRED not empty
-     * @param k index for the selected element
-     */
-    public static void minHeapSelect(Vector<Pair> h1, Vector<Pair> h2, int k){
-        Pair left, right, root;
-        for(int i = 0; i < k-1; i++) {
-            root = h2.get(0);
-            int rootPos = root.getPosition();
-            int l = rootPos * 2 + 1;
-            int r = rootPos * 2 + 2;
-            extract(h2, true);
-            if(l < h1.size()) {
-                left = h1.get(l);
-                left.setPosition(l);
-                h2.add(left);
-                int child = h2.size() - 1;
-                while(child > 0 && h2.get(child).getKey() < h2.get((child - 1) / 2).getKey()) {
-                    Collections.swap(h2, child, (child - 1) / 2);
-                    child = (child - 1) / 2;
-                }
-            }
-            if(r < h1.size()){
-                right = h1.get(r);
-                right.setPosition(r);
-                h2.add(right);
-                int child = h2.size() - 1;
-                while(child > 0 && h2.get(child).getKey() < h2.get((child - 1) / 2).getKey()) {
-                    Collections.swap(h2, child, (child - 1) / 2);
-                    child = (child - 1) / 2;
-                }
-            }
-        }
-    }
-
-    /**
-     * Selects k-th element in a vector with O(k log k) time complexity
-     * @param h1 first vector of Pairs. REQUIRED not empty
-     * @param h2 second vector of Pairs. REQUIRED not empty
-     * @param k index for the selected element
-     */
-    public static void maxHeapSelect(Vector<Pair> h1, Vector<Pair> h2, int k){
-        Pair left, right, root;
-        for(int i = h1.size()-1; i > k-1; i--) {
-            root = h2.get(0);
-            int rootPos = root.getPosition();
-            int l = rootPos * 2 + 1;
-            int r = rootPos * 2 + 2;
-            extract(h2, false);
-            if(l < h1.size()) {
-                left = h1.get(l);
-                left.setPosition(l);
-                h2.add(left);
-                int child = h2.size() - 1;
-                while(child > 0 && h2.get(child).getKey() > h2.get((child - 1) / 2).getKey()) {
-                    Collections.swap(h2, child, (child - 1) / 2);
-                    child = (child - 1) / 2;
-                }
-            }
-            if(r < h1.size()){
-                right = h1.get(r);
-                right.setPosition(r);
-                h2.add(right);
-                int child = h2.size() - 1;
-                while(child > 0 && h2.get(child).getKey() > h2.get((child - 1) / 2).getKey()) {
-                    Collections.swap(h2, child, (child - 1) / 2);
-                    child = (child - 1) / 2;
-                }
-            }
-        }
-    }
-
-    /**
-     * Given a vector of pairs, builds a minHeap
-     * @param vector the vector of pairs
-     */
-    public static void buildMinHeap(Vector<Pair> vector) {
-        for(int i = vector.size()/2 - 1; i >= 0; i--) {
-            minHeapify(vector, i);
-        }
-    }
-
-    /**
-     * Given a vector of pairs, builds a maxHeap
-     * @param vector the vector of pairs
-     */
-    public static void buildMaxHeap(Vector<Pair> vector) {
-        for(int i = vector.size()/2 - 1; i >= 0; i--) {
-            maxHeapify(vector, i);
-        }
-    }
-
-    /**
-     * maxHeapify algorithm with O(log n) or O(log k) time complexity
-     * @param vector the vector of pairs that will be turned into a minHeap
-     * @param i starting index for the algorithm. REQUIRED 0 <= i< vector length
-     */
-    private static void maxHeapify(Vector<Pair> vector, int i) {
-        int n = vector.size();
-        int greatest = i;
-        int l = 2*i + 1;
-        int r = 2*i + 2;
-
-        if(l < n && vector.get(l).getKey() > vector.get(greatest).getKey())
-            greatest = l;
-        if(r < n && vector.get(r).getKey() > vector.get(greatest).getKey())
-            greatest = r;
-        if(greatest != i) {
-            Collections.swap(vector, i, greatest);
-            maxHeapify(vector, greatest);
-        }
-    }
-
-    /**
-     * minHeapify algorithm with O(log n) or O(log k) time complexity
-     * @param vector the vector of pairs that will be turned into a minHeap
-     * @param i starting index for the algorithm. REQUIRED 0 <= i< vector length
-     */
-    public static void minHeapify(Vector<Pair> vector, int i) {
-        int n = vector.size();
-        int smallest = i;
-        int l = 2*i + 1;
-        int r = 2*i + 2;
-
-        if(l < n && vector.get(l).getKey() < vector.get(smallest).getKey())
-            smallest = l;
-        if(r < n && vector.get(r).getKey() < vector.get(smallest).getKey())
-            smallest = r;
-        if(smallest != i) {
-            Collections.swap(vector, i, smallest);
-            minHeapify(vector, smallest);
-        }
-    }
-
-    /**
-     * Extracts the upper element from the vector making sure to keep the minHeap valid
-     * @param vector the heap vector. REQUIRED as a minHeap or a maxHeap
-     * @param min
-     */
-    public static void extract(Vector<Pair> vector, boolean min) {
-        Collections.swap(vector, 0, vector.size() - 1);
-        vector.remove(vector.size() - 1);
-        if(min)
-            minHeapify(vector, 0);
-        else
-            maxHeapify(vector, 0);
-    }
 }
Index: changelog.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>18 APRILE 2020\r\n- Aggiunto un file di template (Time_Template.xlsx) per la creazione del file Time.xlsx\r\n\r\n- Modificata la classe Excel in modo che qualora non esistesse Time.xlsx sia possibile crearlo a partire dal file di template\r\n    - La classe crea un file contenente un foglio di calcolo per ognuna delle 50 lunghewzze di vettore definite dalla funzione apposita\r\n    - Il nome del foglio di calcolo Ã¨ dato dalla lunghezza del vettore a cui sono riferiti i tempi\r\n\r\n- Modificata la funzione per il calcolo delle lunghezze sia in Excel che in Time\r\n\r\n- Ricalcolati i tempi sulle nuove lunghezze\r\n\r\n27 APRILE 2020\r\n- HeapSelect ha ricevuto piccole modifiche di ottimizzazione del codice\r\n\r\n- La selezione ora avviene con una funzione principale (medianSelect) e una secondaria (mediansOfMedians) ricorsiva che gestisce le mediane sempre in modo in-place\r\n\r\n- A medianSelect ora basta passare l'array, l, r e k (diminuito alla chiamata di 1)\r\n\r\n- La funzione medianOfMedians riordina ricorsivamente le mediane in modo che all'ultima ricorsione la mediana delle mediane si trovi in posizione l e richiede come parametri l'array e i due indici tra cui sono contenute le mediane
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- changelog.txt	(revision dcec723ca5db19a617442151a50264606ea60349)
+++ changelog.txt	(date 1588621355084)
@@ -10,7 +10,7 @@
 - Ricalcolati i tempi sulle nuove lunghezze
 
 27 APRILE 2020
-- HeapSelect ha ricevuto piccole modifiche di ottimizzazione del codice
+- Old_HeapSelect ha ricevuto piccole modifiche di ottimizzazione del codice
 
 - La selezione ora avviene con una funzione principale (medianSelect) e una secondaria (mediansOfMedians) ricorsiva che gestisce le mediane sempre in modo in-place
 
Index: src/Old_HeapSelect.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Old_HeapSelect.java	(date 1588621355096)
+++ src/Old_HeapSelect.java	(date 1588621355096)
@@ -0,0 +1,255 @@
+import java.util.Vector;
+import java.util.Collections;
+
+/**
+ * Defines pair object that will be used for storing a pair (key, original position) during heap selection algorithm
+ */
+
+class Pair {
+    Integer key;
+    Integer position;
+
+    /**
+     * Constructor for a pair
+     * @param key REQUIRED Not null
+     * @param position REQUIRED not null
+     */
+    Pair(Integer key, Integer position) {
+        this.key = key;
+        this.position = position;
+    }
+
+    /**
+     * getter for key
+     */
+    public Integer getKey() {
+        return key;
+    }
+
+    /**
+     * setter for key
+     */
+    public void setKey(Integer key) {
+        this.key = key;
+    }
+
+
+    /**
+     * getter for position
+     */
+    public Integer getPosition() {
+        return position;
+    }
+
+    /**
+     * setter for position
+     */
+    public void setPosition(Integer position) {
+        this.position = position;
+    }
+}
+
+public class Old_HeapSelect {
+    /*
+    public static void main(String[] args) {
+        System.out.print("Enter an array of integers: ");
+        Scanner input = new Scanner(System.in);
+        String inVector =  input.nextLine();
+        int[] array = getInputVector(inVector);
+        System.out.print("Enter an integer: ");
+        int k = input.nextInt();
+
+        heapSelect(array, k);
+    }*/
+
+    /**
+     * Splits the input line in all the different values
+     * @param inputLine required as a string of ints divided by one (or more) blank spaces
+     * @return an int array containing all the ints from the input
+     */
+    static int[] getInputVector(String inputLine) {
+        String els[] = inputLine.split("\\s+");
+        int length = els.length;
+        int[] output = new int[length];
+        for (int i = 0; i < length; i++) {
+            output[i] = Integer.parseInt(els[i]);
+        }
+        return output;
+    }
+
+    /**
+     * Build the auxiliary data structures basing on the input and runs min/max heapSelect according to input's size
+     * @param array the array with input values. REQUIRED not empty, at least one element
+     * @param k index for the algorithm, REQUIRED 0<=k< array length
+     */
+    public static void heapSelect(int[] array, int k){
+        Vector<Pair> h1 = new Vector<Pair>(10);
+        for (int i : array)
+            h1.add(new Pair(i, null));
+        if (k <= h1.size()/2)
+            buildMinHeap(h1);
+        else
+            buildMaxHeap(h1);
+        Vector<Pair> h2 = new Vector<Pair>(k);
+        Pair root = h1.get(0);
+        root.setPosition(0);
+        h2.add(root);
+
+        if (k <= h1.size()/2)
+            minHeapSelect(h1, h2, k);
+        else
+            maxHeapSelect(h1, h2, k);
+
+        //System.out.println(h2.get(0).getKey());
+    }
+
+    /**
+     * Selects k-th element in a vector with O(k log k) time complexity
+     * @param h1 first vector of Pairs. REQUIRED not empty
+     * @param h2 second vector of Pairs. REQUIRED not empty
+     * @param k index for the selected element
+     */
+    public static void minHeapSelect(Vector<Pair> h1, Vector<Pair> h2, int k){
+        Pair left, right, root;
+        for(int i = 0; i < k-1; i++) {
+            root = h2.get(0);
+            int rootPos = root.getPosition();
+            int l = rootPos * 2 + 1;
+            int r = rootPos * 2 + 2;
+            extract(h2, true);
+            if(l < h1.size()) {
+                left = h1.get(l);
+                left.setPosition(l);
+                h2.add(left);
+                int child = h2.size() - 1;
+                while(child > 0 && h2.get(child).getKey() < h2.get((child - 1) / 2).getKey()) {
+                    Collections.swap(h2, child, (child - 1) / 2);
+                    child = (child - 1) / 2;
+                }
+            }
+            if(r < h1.size()){
+                right = h1.get(r);
+                right.setPosition(r);
+                h2.add(right);
+                int child = h2.size() - 1;
+                while(child > 0 && h2.get(child).getKey() < h2.get((child - 1) / 2).getKey()) {
+                    Collections.swap(h2, child, (child - 1) / 2);
+                    child = (child - 1) / 2;
+                }
+            }
+        }
+    }
+
+    /**
+     * Selects k-th element in a vector with O(k log k) time complexity
+     * @param h1 first vector of Pairs. REQUIRED not empty
+     * @param h2 second vector of Pairs. REQUIRED not empty
+     * @param k index for the selected element
+     */
+    public static void maxHeapSelect(Vector<Pair> h1, Vector<Pair> h2, int k){
+        Pair left, right, root;
+        for(int i = h1.size()-1; i > k-1; i--) {
+            root = h2.get(0);
+            int rootPos = root.getPosition();
+            int l = rootPos * 2 + 1;
+            int r = rootPos * 2 + 2;
+            extract(h2, false);
+            if(l < h1.size()) {
+                left = h1.get(l);
+                left.setPosition(l);
+                h2.add(left);
+                int child = h2.size() - 1;
+                while(child > 0 && h2.get(child).getKey() > h2.get((child - 1) / 2).getKey()) {
+                    Collections.swap(h2, child, (child - 1) / 2);
+                    child = (child - 1) / 2;
+                }
+            }
+            if(r < h1.size()){
+                right = h1.get(r);
+                right.setPosition(r);
+                h2.add(right);
+                int child = h2.size() - 1;
+                while(child > 0 && h2.get(child).getKey() > h2.get((child - 1) / 2).getKey()) {
+                    Collections.swap(h2, child, (child - 1) / 2);
+                    child = (child - 1) / 2;
+                }
+            }
+        }
+    }
+
+    /**
+     * Given a vector of pairs, builds a minHeap
+     * @param vector the vector of pairs
+     */
+    public static void buildMinHeap(Vector<Pair> vector) {
+        for(int i = vector.size()/2 - 1; i >= 0; i--) {
+            minHeapify(vector, i);
+        }
+    }
+
+    /**
+     * Given a vector of pairs, builds a maxHeap
+     * @param vector the vector of pairs
+     */
+    public static void buildMaxHeap(Vector<Pair> vector) {
+        for(int i = vector.size()/2 - 1; i >= 0; i--) {
+            maxHeapify(vector, i);
+        }
+    }
+
+    /**
+     * maxHeapify algorithm with O(log n) or O(log k) time complexity
+     * @param vector the vector of pairs that will be turned into a minHeap
+     * @param i starting index for the algorithm. REQUIRED 0 <= i< vector length
+     */
+    private static void maxHeapify(Vector<Pair> vector, int i) {
+        int n = vector.size();
+        int greatest = i;
+        int l = 2*i + 1;
+        int r = 2*i + 2;
+
+        if(l < n && vector.get(l).getKey() > vector.get(greatest).getKey())
+            greatest = l;
+        if(r < n && vector.get(r).getKey() > vector.get(greatest).getKey())
+            greatest = r;
+        if(greatest != i) {
+            Collections.swap(vector, i, greatest);
+            maxHeapify(vector, greatest);
+        }
+    }
+
+    /**
+     * minHeapify algorithm with O(log n) or O(log k) time complexity
+     * @param vector the vector of pairs that will be turned into a minHeap
+     * @param i starting index for the algorithm. REQUIRED 0 <= i< vector length
+     */
+    public static void minHeapify(Vector<Pair> vector, int i) {
+        int n = vector.size();
+        int smallest = i;
+        int l = 2*i + 1;
+        int r = 2*i + 2;
+
+        if(l < n && vector.get(l).getKey() < vector.get(smallest).getKey())
+            smallest = l;
+        if(r < n && vector.get(r).getKey() < vector.get(smallest).getKey())
+            smallest = r;
+        if(smallest != i) {
+            Collections.swap(vector, i, smallest);
+            minHeapify(vector, smallest);
+        }
+    }
+
+    /**
+     * Extracts the upper element from the vector making sure to keep the minHeap valid
+     * @param vector the heap vector. REQUIRED as a minHeap or a maxHeap
+     * @param min
+     */
+    public static void extract(Vector<Pair> vector, boolean min) {
+        Collections.swap(vector, 0, vector.size() - 1);
+        vector.remove(vector.size() - 1);
+        if(min)
+            minHeapify(vector, 0);
+        else
+            maxHeapify(vector, 0);
+    }
+}
